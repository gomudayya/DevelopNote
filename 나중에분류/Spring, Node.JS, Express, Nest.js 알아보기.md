## Intro

지금까지 스프링을 기반으로 백엔드 기술을 학습하여 왔는데, 운이 좋게도 Node.JS 계열의 스택을 사용하는 회사에서 면접을 보게 될 기회가 주어졌다. 여태 스프링만 다뤄왔던 지라 다른 스택에 대해서는 문외한이기도 하고, 각각의 기술들이 어떠한 문제를 해결하기 위해 등장했을지 궁금해져서 알아보기로 했다. (면접 대비도 할 겸.. ㅎㅎ) 

<br/>

## Spirng

스프링 이전에는 JAVA EE라는 기술을 사용하였는데, 아래와 같은 단점이 있었다.

- XML기반 설정을 이용하기 때문에, 설정이 복잡하였다. 

- 대형 어플리케이션 서버(JBoss, Glassfish 등)에 의존하여 실행되었다. 굉장히 무거운 환경에서 실행되었고, 배포 과정이 복잡하였다.

  - 현재 Spring에서는 프로젝트 안에 Tomcat과 같은 경량화된 서버를 내장한다. 경량화된 서버들은 HTTP 요청/응답 관련의 최소한의 기능만 지원한다.
  
  - 하지만 이 시절에는 트랜잭션 관리, DB연결 관리, 메시징 서비스 등 모든 기능을 지원하는 대형 서버에 의존했다고 한다.
  
  - 개발자가 개발을 하면 대형 서버의 컨테이너 위에 올라가서, 실행되는 방식이다. 
  
  - 당시에는 엔터프라이즈 어플리케이션에서 필요한 모든 것을 한 번에 지원하고자 이렇게 설계한 것 같다. 
  
-  무거운 객체와 강한 결합으로 인해 단위 테스트 코드 작성이 어려웠다.

<br/>

스프링은 2003년도에 로드 존슨 선생님이 본인의 저서에서 선보인 소스코드에서 시작되었다. DI, IoC, AOP는 스프링의 핵심 아이디어이며, 기존 JavaEE 시절의 문제들을 아래와 같이 해결하였다.

<br/>

- XML 기반 설정이 아닌 Bean 객체를 갈아 끼우는 방식으로 설정을 변경할 수 있다. 즉 XML이 아닌 소스코드에서도 설정을 관리할 수 있게 되었다.

-  IoC컨테이너를 이용하여, 객체 관리에 대한 부담을 덜어주었다. DI를 이용해 느슨한 결합의 형태로 소스 코드가 작성될 수 있도록 해주었다.

-  AOP 이용하여 트랜잭션 관리를 대형 서버가 아닌 내부 프레임워크 안에서 할 수 있게 되었다.

-  Tomcat 과 같은 HTTP 통신과 관련된 최소한의 기능만 가진 경량화된 서버를 내장 시켰다. 기존의 대규모 서버에서 제공하던 기능들은 모듈화 하여 이식하는 방식으로 전환되었다.

- 단위 테스트 작성 또한 DI 원리를 이용하여, 테스트 작성이 용이하도록 하였다.

<br/>

## Node.JS

원래 Javascript는 HTML을 조작하기 위한 목적으로 브라우저 안에서만 실행 되었지만, 브라우저 이외의 다른 환경에서 실행하도록 만든 것이 Node.JS이다. 뛰어난 성능의 크롬V8엔진을 기반으로 만들어졌다. Node.JS 자체는 프레임워크나 라이브러리가 아니고, 그저 자바스크립트의 런타임 환경이다.

> 하나의 웹 어플리케이션이라는 관점에서 바라봤을 때,
클라이언트와 서버 양쪽에서 왜 다른 언어를 사용해야 하는가?


라는 생각에서 시작 된 것이 Node.JS이다. 클라이언트와 서버 양쪽 다 같은 언어를 사용하기 때문에, 동일한 라이브러리, API 사용이 가능하다는 이점도 있고, 특히 스타트업 같은 경우에는 개발 팀을 적은 비용으로 빌딩할 수 있기 때문에, 선호 되는 것 같다.

<br/>

**[ 주요 특징 ]**

- 싱글스레드 이벤트루프 모델이다. ( Java Spring의 경우 Request Per Thread 모델이다.)

  - Node.JS는 처음 Request를 받을 때 싱글스레드에서 처리한다.
  
  - 하지만 I/O 작업을 수행할 때에는, libuv이라는 라이브러리에서 비동기적으로 실행된다.
  
  - libuv이라는 라이브러리는 비동기 non-block I/O를 지원하는 C 라이브러리 이다.  
  
  - libuv 라이브러리는 멀티스레드를 기반으로 동작하므로, Node.JS를 단순히 싱글스레드다! 라고 단정짓는 것은 무리가 있다.
  - I/O Bound 작업이 많은 서버라면, Node.JS가 효율적일 수 있다. 
	  (상대적으로 스프링에 비해 컨텍스트 스위칭비용이 적긴 한 것 같다.)
  - 하지만 무거운 CPU Bound 연산이 자주 실행된다면 메인 쓰레드가 블로킹되서 사용자 경험이 안 좋아질 수 있으니 주의해야 한다.

-  Node.JS 계열은 상당히 경량화된 환경이다. 기본 메모리 사용량이나, 배포 시간에 있어서 JVM 계열에 비해 장점이 있는 것 같다.

<br/>

## Express.js

Node.JS 자체는 자바스크립트의 런타임 실행 환경 이였고, 웹 서버를 빠르게 구축할 수 있도록 하는 프레임워크가 필요했다. 그렇게 등장한 것이 Express이다. 경량화된 웹 프레임워크이며, 자유도가 굉장히 높다고 한다. 

라우팅, 에러핸들링, 미들웨어(Spring의 필터 느낌?)와 같은 웹서버 개발에 필요한 최소한의 기능들만 지원하고, 아키텍처 설계는 개발자에게 맡기는 것 같다. 반면 Spring에서는 @Controller @Service @Repository와 같은 계층별 컴포넌트 어노테이션이 존재하고, 이에 따라 아키텍처 설계가 고정되는 경향이 있다. 또한 IoC 컨테이너가 객체의 라이프 사이클을 관리하는 등 소스코드 제어권을 프레임워크에서 많이 가져간다.

고정된 아키텍처가 있다는 것은 러닝 커브를 발생 시키지만 협업 하기는 다소 수월하다는 장점이 있다. 이에 반해 Express는 자유도가 높기 때문에 처음 시작은 편리하지만, 고도화 되었을 때 코드의 퀄리티 저하나, 새로 합류하는 사람 입장에서 프로젝트 구조를 파악하기가 어렵다는 단점이 있을 수 있다.

<br/>

### Nest.js

Express 기반에서 만들어 졌지만, Express의 높은 자유도에서 생기는 단점을 극복하기 위해 나온 프레임워크이다. Angular의 아키텍처를 차용해서 만들어졌다고 한다.

아래와 같은 특징이 있다.

-  DI/IoC 패턴을 사용하여, 유연성과 테스트 용이성을 높인다.
-  Javascript로도 사용이 가능하지만 Typescript를 지향한다. 
-  데코레이터를 활용하여 설정을 처리한다. (Spring의 어노테이션과 유사함.)
-  Security, WebSockets, Microservice와 같은 다양한 분야의 개발을 지원한다.

Spring과 매우 유사하다고 해서 예제 소스 코드를 살짝 봤는데 정말 그렇다.. 
Node.JS만의 독창적인 컨셉을 지켜나가기 원하는 개발자라면 싫어할 수 있을 것 같다는 생각이 들었다. 


<br/>

---

<br/>


주절주절 쓰긴 했는데, Node 계열은 사실 모르는 것이 많아서 쉽사리 적기가 어려웠다. 그래도 스프링에 대해서만 공부해 왔는데, 다른 쪽 진영에 대해 공부해보니 신선하게 다가왔고, 재미있었다.





---
참고자료
https://www.quora.com/What-are-the-problems-Spring-framework-solves-over-Java
https://www.quora.com/Why-should-I-prefer-Spring-Framework-over-Java-EE
https://www.netguru.com/glossary/node-js#what-is-nodejs-and-why-does-it-matter
https://www.reddit.com/r/AskProgramming/comments/52pn17/why_does_nodejs_exist/
https://codegear.tistory.com/53
https://medium.com/deno-the-complete-reference/express-vs-springboot-hello-world-performance-comparison-dd066bf53858
https://docs.nestjs.com/#philosophy
